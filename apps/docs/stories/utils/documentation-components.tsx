import { Source } from '@storybook/blocks';
import dedent from 'ts-dedent';

export const ExportedParts = ({ tags, component, compact }: { tags: string[]; component: string, compact: boolean }) => {
  return (
    <ul>
      {tags.map(text => {
        const splitText = text.split(':');
        const part = splitText[0];
        const description = splitText[1];
        return (
          <li key={part}>
            <strong>{part}</strong> {description ? '- ' + description : ''}
            <ExportedPartUsage component={component} tag={part} compact={compact} />
          </li>
        );
      })}
    </ul>
  );
};

export const ExportedPartUsage = ({ tag, component, compact }: { tag: string; component: string, compact?: boolean }) => (
  <Source
    dark
    language="css"
    code={dedent(`
      ${component || '*'}::part(${tag}) ${!compact ? `{
        color: red;
      }` : '{}'}
    `)}
  />
);

export const SummaryElement = (props: { title: string, children: any }) => {
  const { title, children } = props;

  return (
    <details style={{
      fontFamily: 'var(--bs-font-sans-serif)',
      color: '#2E3438',
      fontSize: '14px',
      cursor: 'pointer'
    }}>
      <summary>
        <b>{title}</b>
      </summary>

      {children}
    </details>
  );
};

// If there's only one role, return <code>{role}</code>, 
// otherwise return <code>{role1} or {role2}</code>
const getComponentRole = ({ actions, entity, identification }: {
  actions: string[],
  entity: string,
  identification: string
}) => {
  const getCodeForRole = (role: string) => (
    <code>{`${role}:${entity}:${identification}`}</code>
  );

  if (actions.length === 1) {
    return getCodeForRole(actions[0]);
  }

  return (
    <>
      {actions.map((role, i) => {
        return `
        ${getCodeForRole(role)}
        ${i < actions.length - 1 ? ' or ' : ''}
      `
      })}
    </>
  );
};

export const AuthTokenDescription = () => (
  <>
    <strong>Create Access Token API</strong >: These tokens are generated by your backend services using the {' '}
    <a href="https://docs.justifi.tech/api-spec#tag/API-Credentials/operation/CreateAccessToken">
      Auth Token API
    </a>.
  </>
)

const WebComponentTokenDescription = ({ actions, entity, identification }: {
  actions: string[],
  entity: string,
  identification: string
}) => {
  const componentRole = getComponentRole({ actions, entity, identification });

  return (
    <>
      <strong> Web Component Token</strong>: These tokens are generated by your backend services using the{' '}
      <a href="https://docs.justifi.tech/api-spec#tag/Web-Component-Tokens/operation/CreateWebComponentToken">
        Web Component Tokens API
      </a>.
      Each token can be scoped to perform a set number of actions and is active for 60 minutes.
      When creating a web component token for this specific component you'll need to use the role {componentRole}
      (use the <code>{identification}</code> you also pass as a separate prop).
    </>
  );
};

type Role = { action: string; entity: string; id: string };

const parseResources = (resources: string[]): Role[] =>
  resources.map((resource) => {
    const [action, entity, id] = resource.split(':');
    return { action, entity, id };
  });

const buildRoles = (props: AuthorizationProps): Role[] => {
  if (Array.isArray(props.resources)) {
    return parseResources(props.resources);
  }
  if (props.actions && props.entity && props.identification) {
    return [{ action: props.actions, entity: props.entity, id: props.identification }];
  }
  return [];
};

const formatRoleStrings = (roles: Role[]): string[] =>
  roles.map((r) => `${r.action}:${r.entity}:${r.id}`);

const formatIdList = (ids: string[]) => {
  return ids.map((id, i) => <code key={i}>{id}</code>).reduce((prev, curr, i) => {
    if (i === 0) return curr;
    if (i === ids.length - 1) return <>{prev} and {curr}</>;
    return <>{prev}, {curr}</>;
  });
};


interface AuthorizationProps {
  actions?: 'read' | 'write';
  entity?: 'tokenize' | 'business' | 'account' | 'checkout' | 'payments' | 'dispute';
  identification?: 'client_id' | 'business_id' | 'checkout_id' | 'account_id';
  resources?: string[];
}
export const Authorization = (props: AuthorizationProps) => {
  const roles = buildRoles(props);
  const roleStrings = formatRoleStrings(roles);
  const uniqueIds = Array.from(new Set(roles.map((r) => r.id)));

  return (
    <>
      <p>
        Authorization is performed by passing a web component token as <code>auth-token</code>.
      </p>
      <ul>
        <li>
          <strong>Web Component Token</strong>: These tokens are generated by your backend services using the{' '}
          <a href="https://docs.justifi.tech/api-spec#tag/Web-Component-Tokens/operation/CreateWebComponentToken">
            Web Component Tokens API
          </a>. Each token can be scoped to perform a set number of actions and is active for 60 minutes.{' '}
          When creating a web component token for this specific component you'll need to use the role
          {roles.length > 1 ? 's' : ''}:{' '}
          {roleStrings.map((str, i) => (
            <span key={i}><code>{str}</code></span>
          ))}.
          Make sure the value{uniqueIds.length > 1 ? 's' : ''} for {formatIdList(uniqueIds)} match the prop
          {uniqueIds.length > 1 ? 's' : ''} you also pass separately.
        </li>
      </ul>
    </>
  );
};


// A box where to render the component inside
export const ComponentBox = ({ children }: { children: any }) => {
  return (
    <div style={{
      border: '1px solid #E0E0E0',
      borderRadius: '4px',
      padding: '16px',
      marginBottom: '16px',
      marginTop: '20px'
    }}>
      {children}
    </div>
  );
}
